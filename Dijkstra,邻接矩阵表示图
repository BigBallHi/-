import java.util.Scanner;

public class Main{
	
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		int n = in.nextInt();
		int s = in.nextInt();
		int[][] g = new int[n+1][n+1];
		for(int i = 1;i<=s;i++){
			g[in.nextInt()][in.nextInt()] = in.nextInt();
		}
		in.close();
		for(int j = 0;j<=n;j++){
			for(int k = 0;k<=n;k++){
				if(g[j][k]==0){
					g[j][k]=1000;
				}
			}
		}
		dijkstra(g);
 	}
	
	public static void dijkstra(int[][] g){
		//s为题目给的边的个数
		//将g第一行和第一列空出来，n为有效元素个数，即节点数
		int n = g[0].length-1;
		//dijk表示已知的最短路径
		int[] dijk = new int[n+1];
		//isMin[i] = true表示i节点已找到最短路径
		boolean[] isMin = new boolean[n+1];
		//side存储最短路径
		int[] side = new int[n+1];
		
		//初始化dijk【】
		for(int i =1;i<=n;i++){
			dijk[i] = g[1][i];
		}
		
		int k = 1;//表示最短找到的最短路径的终点，也是下一次的起点
		isMin[k] = true;
		for(int i = 1;i<=n-1;i++){
			//通过k为起点，更新dijk数列
			for(int j = 1;j<=n;j++){
				if(dijk[k]+g[k][j]<dijk[j]&&isMin[j]==false){
					dijk[j] = dijk[k]+g[k][j];
				}
			}
			//找出dijk数组的最小值，将下标赋值给k，修改ISMIN数组的值，将结果赋到side【】
			int m = 999;
			int w=0;//下标
			for(int z = 1;z<=n;z++){
				if(dijk[z]<m&&isMin[z]==false){
					m = dijk[z];
					w = z;
					side[z] = dijk[z];
				}
					
			}
			
			k=w;
			isMin[w] = true;
			System.out.println(w+":"+dijk[w]);
			
		}
		
	}
}
